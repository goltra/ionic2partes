"use strict";
var build_1 = require('./build');
var config_1 = require('./util/config');
var logger_1 = require('./util/logger');
var chalk = require('chalk');
var chokidar = require('chokidar');
// https://github.com/paulmillr/chokidar
function watch(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    // force watch options
    context.isProd = false;
    context.isWatch = true;
    var logger = new logger_1.Logger('watch');
    function buildDone() {
        return startWatchers(context, configFile).then(function () {
            logger.ready(chalk.green);
        });
    }
    return build_1.build(context)
        .then(buildDone, buildDone)
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.watch = watch;
function startWatchers(context, configFile) {
    var watchConfig = config_1.fillConfigDefaults(configFile, taskInfo.defaultConfigFile);
    var promises = watchConfig
        .watchers
        .filter(function (w) { return w.callback && w.paths; })
        .map(function (w) { return startWatcher(w, context, watchConfig); });
    return Promise.all(promises);
}
function startWatcher(watcher, context, watchConfig) {
    return new Promise(function (resolve, reject) {
        var taskPromise = Promise.resolve();
        var nextTask = null;
        var watcherOptions = watcher.options || {};
        if (!watcherOptions.cwd) {
            watcherOptions.cwd = context.rootDir;
        }
        if (typeof watcherOptions.ignoreInitial !== 'boolean') {
            watcherOptions.ignoreInitial = true;
        }
        var paths = cleanPaths(context, watcher.paths);
        var chokidarWatcher = chokidar.watch(paths, watcherOptions);
        chokidarWatcher.on('all', function (event, path) {
            config_1.setIonicEnvironment(context.isProd);
            logger_1.Logger.debug("watch callback start, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + path);
            function taskDone() {
                logger_1.Logger.info(chalk.green('watch ready'));
            }
            nextTask = watcher.callback.bind(null, event, path, context);
            taskPromise.then(function () {
                logger_1.Logger.debug("watch callback complete, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + path);
                taskPromise = nextTask();
                taskPromise
                    .then(taskDone, taskDone)
                    .catch(taskDone);
                nextTask = null;
                watchCount++;
            }).catch(function (err) {
                logger_1.Logger.debug("watch callback error, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + path);
                logger_1.Logger.debug("" + err);
                taskPromise = nextTask();
                taskPromise
                    .then(taskDone, taskDone)
                    .catch(taskDone);
                nextTask = null;
                watchCount++;
            });
        });
        chokidarWatcher.on('ready', function () {
            logger_1.Logger.debug("watcher ready: " + watcherOptions.cwd + paths);
            resolve();
        });
        chokidarWatcher.on('error', function (err) {
            reject(new logger_1.BuildError("watcher error: " + watcherOptions.cwd + paths + ": " + err));
        });
    });
}
function cleanPaths(context, paths) {
    if (Array.isArray(paths)) {
        return paths.map(function (p) { return config_1.replacePathVars(context, p); });
    }
    if (typeof paths === 'string') {
        return config_1.replacePathVars(context, paths);
    }
    return paths;
}
var taskInfo = {
    fullArgConfig: '--watch',
    shortArgConfig: '-w',
    envConfig: 'ionic_watch',
    defaultConfigFile: 'watch.config'
};
var watchCount = 0;
